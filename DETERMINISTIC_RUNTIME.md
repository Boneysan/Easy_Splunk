# Deterministic Runtime Selection

## Overview

Easy_Splunk now uses a **deterministic runtime selection system** that ensures consistent container runtime choice across all scripts and sessions. This eliminates the "surprising behavior" that could occur on RHEL-like hosts due to subtle branching paths.

## How It Works

### 1. Single Detection Function
The `detect_runtime()` function in `lib/runtime-detection.sh` codifies the exact precedence:

```bash
# Priority 1: Docker (if available and working)
if command -v docker >/dev/null 2>&1; then
    if timeout 10s docker info >/dev/null 2>&1; then
        # Use Docker
    fi
fi

# Priority 2: Podman (if available, working, and compose subcommand supported)
if command -v podman >/dev/null 2>&1; then
    if timeout 10s podman info >/dev/null 2>&1; then
        if podman compose version >/dev/null 2>&1; then
            # Use Podman with native compose
        fi
    fi
fi

# Priority 3: Error with actionable hints
# No suitable runtime found
```

### 2. Lockfile Caching
Runtime decisions are cached in `.orchestrator.lock`:

```bash
# Container Runtime Lockfile
# Generated by detect_runtime() on Wed Aug 27 11:41:49 MDT 2025
# This file ensures deterministic runtime selection across sessions

RUNTIME=podman
COMPOSE=podman compose
TIMESTAMP=1756316509
PID=31751
```

### 3. Centralized Entry Points
All scripts now read from the lockfile first:

- `orchestrator.sh` - Uses `source_runtime_config()`
- `deploy.sh` - Uses centralized `detect_runtime()`
- `start_cluster.sh` - Uses centralized `detect_runtime()`
- `stop_cluster.sh` - Uses centralized `detect_runtime()`

## Usage

### Automatic Detection
Runtime detection happens automatically when any Easy_Splunk script runs for the first time:

```bash
./orchestrator.sh  # Automatically detects and caches runtime
```

### Manual Management
Use the management script for runtime control:

```bash
# Check current status
./manage-runtime.sh status

# Force redetection
./manage-runtime.sh detect

# Clear cache (forces fresh detection)
./manage-runtime.sh clear

# Show available runtime variables
./manage-runtime.sh show
```

### Testing
Run the comprehensive test suite:

```bash
./test-deterministic-runtime.sh
```

## Benefits

### ✅ Eliminates Surprising Behavior
- No more OS-specific branching confusion
- Consistent behavior across RHEL 8, Ubuntu, Debian
- No Python 3.6 walrus operator issues with podman-compose

### ✅ Idempotent Across Sessions
- Runtime choice persists across terminal sessions
- All scripts use the same cached decision
- No re-detection unless explicitly requested

### ✅ Clear Error Messages
When no suitable runtime is found, users get actionable installation hints:

```
❌ No suitable container runtime found!

Install options:
  • Docker: https://docs.docker.com/get-docker/
  • Podman: https://podman.io/getting-started/installation

For Podman, ensure 'podman compose' subcommand is available:
  • RHEL/CentOS: dnf install podman-compose
  • Ubuntu/Debian: apt install podman-compose
  • Or install docker-compose as fallback
```

### ✅ Backward Compatible
- Existing configurations still work
- Config file `CONTAINER_RUNTIME` setting still respected
- No breaking changes to existing workflows

## Implementation Details

### Files Modified
- `lib/runtime-detection.sh` - Added `detect_runtime()`, `_write_runtime_lockfile()`, etc.
- `orchestrator.sh` - Updated `source_runtime_config()` to read lockfile first
- `deploy.sh` - Replaced local detection with centralized function
- `start_cluster.sh` - Replaced Docker-first logic with centralized detection
- `stop_cluster.sh` - Replaced Docker-first logic with centralized detection

### New Files Created
- `manage-runtime.sh` - Utility script for runtime management
- `test-deterministic-runtime.sh` - Comprehensive test suite

### Lockfile Format
The `.orchestrator.lock` file uses a simple key=value format:

```
# Container Runtime Lockfile
# Generated by detect_runtime() on [timestamp]
# This file ensures deterministic runtime selection across sessions

RUNTIME=docker|podman
COMPOSE=docker compose|podman compose|etc
TIMESTAMP=unix_timestamp
PID=process_id
```

## Migration Notes

### For Existing Users
- No action required - the system automatically detects and caches
- Existing `CONTAINER_RUNTIME` config settings still work
- Lockfile takes precedence over auto-detection but respects config

### For Developers
- Use `detect_runtime()` instead of custom detection logic
- Check lockfile first, then config file, then auto-detect
- Use `force_redetect=true` parameter for testing/debugging

## Troubleshooting

### Force Fresh Detection
```bash
./manage-runtime.sh clear  # Clear lockfile
./manage-runtime.sh detect # Force redetection
```

### Debug Runtime Issues
```bash
./manage-runtime.sh status  # Show detailed status
```

### Override Detection
Set `CONTAINER_RUNTIME` in `config/active.conf` to override auto-detection.

---

**Result**: Runtime selection is now deterministic, cached, and consistent across all Easy_Splunk components. No more surprising behavior on RHEL-like hosts!</content>
<parameter name="filePath">/mnt/d/GitHub/Rhel8_Splunk/Easy_Splunk/DETERMINISTIC_RUNTIME.md
