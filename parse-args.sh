#!/usr/bin/env bash
#
# ==============================================================================
# parse-args.sh
# Enhanced argument parsing + config templating for orchestrator.sh
#
# Dependencies: lib/core.sh (log_*, die, is_true, is_empty, is_number)
#               lib/validation.sh (validate_required_var, validate_or_prompt_for_dir)
# ==============================================================================

# ---- Dependency guard ----------------------------------------------------------
if ! command -v log_info >/dev/null 2>&1 || ! command -v validate_required_var >/dev/null 2>&1; then
  echo "FATAL: lib/core.sh and lib/validation.sh must be sourced before parse-args.sh" >&2
  exit 1
fi

# ---- Defaults (honor pre-set env; otherwise set) --------------------------------
: "${APP_PORT:=8080}"
: "${DATA_DIR:=/var/lib/my-app}"
: "${ENABLE_MONITORING:=false}"
: "${INTERACTIVE_MODE:=false}"
: "${APP_CPU_LIMIT:=1.5}"
: "${APP_MEM_LIMIT:=2G}"
: "${NON_INTERACTIVE:=0}"        # if 1, ignore -i/--interactive
: "${OUTPUT_EFFECTIVE_CONFIG:=}" # path to write normalized config (optional)

# ---- Usage ---------------------------------------------------------------------
_usage() {
  cat <<EOF
Usage: orchestrator.sh [options]

Options:
  --config <file>        Load key=value defaults from a template file (POSIX .env style)
  --port <port>          Public port for the app (default: ${APP_PORT})
  --data-dir <path>      Persistent data directory (default: ${DATA_DIR})
  --with-monitoring      Enable Prometheus & Grafana
  --no-monitoring        Disable monitoring (overrides template/env)
  -i, --interactive      Prompt for missing values (ignored if NON_INTERACTIVE=1)
  --app-cpu <limit>      CPU limit for app (e.g., 1.5)
  --app-mem <limit>      Memory limit for app (e.g., 2G)
  --write-effective <f>  Write normalized config (key=value) to file <f>
  -h, --help             Show this help and exit

Precedence: defaults < --config file < environment variables < CLI flags
EOF
}

# ---- Helpers -------------------------------------------------------------------
_load_env_file() {
  # load a .env-like file safely (KEY=VALUE pairs, allows quotes and comments)
  local f="${1:?config file required}"
  [[ -f "$f" ]] || die "${E_INVALID_INPUT}" "Configuration file not found: ${f}"
  log_info "Loading configuration from template: ${f}"

  # shellcheck disable=SC1090
  while IFS= read -r line || [[ -n "$line" ]]; do
    # trim leading/trailing whitespace
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%"${line##*[![:space:]]}"}"
    # skip blanks and comments
    [[ -z "$line" || "${line:0:1}" == "#" ]] && continue
    # only accept KEY=VALUE
    if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
      local k="${BASH_REMATCH[1]}"
      local v="${BASH_REMATCH[2]}"
      # strip surrounding quotes if present
      if [[ "$v" =~ ^\"(.*)\"$ ]]; then v="${BASH_REMATCH[1]}"; fi
      if [[ "$v" =~ ^\'(.*)\'$ ]]; then v="${BASH_REMATCH[1]}"; fi
      # only set if variable is currently unset (template < env < CLI)
      if [[ -z "${!k+x}" ]]; then
        printf -v "$k" '%s' "$v"
        export "$k"
      fi
    else
      log_warn "Ignoring invalid line in ${f}: ${line}"
    fi
  done < "$f"
}

_write_effective_config() {
  local out="${1:?output file required}"
  umask 077
  cat > "${out}" <<EOF
# Normalized configuration generated by parse-args.sh
APP_PORT=${APP_PORT}
DATA_DIR=${DATA_DIR}
ENABLE_MONITORING=${ENABLE_MONITORING}
APP_CPU_LIMIT=${APP_CPU_LIMIT}
APP_MEM_LIMIT=${APP_MEM_LIMIT}
EOF
  log_info "Wrote effective config to: ${out}"
}

_validate_values() {
  # Port sanity
  if ! is_number "${APP_PORT}" || (( APP_PORT < 1 || APP_PORT > 65535 )); then
    die "${E_INVALID_INPUT}" "Invalid --port '${APP_PORT}'. Must be 1..65535."
  fi
  # Data dir present or interactive recovery
  if is_true "${INTERACTIVE_MODE}" && (( NON_INTERACTIVE == 0 )); then
    validate_or_prompt_for_dir "DATA_DIR" "application data"
  else
    validate_required_var "${DATA_DIR}" "Data Directory (--data-dir)"
  fi
}

# ---- Main ----------------------------------------------------------------------
parse_arguments() {
  local argv=("$@")

  # First pass: isolate --config to populate defaults early
  local i=0
  while (( i < ${#argv[@]} )); do
    case "${argv[$i]}" in
      --config)
        local cfg="${argv[$((i+1))]:-}"
        [[ -n "$cfg" ]] || die "${E_INVALID_INPUT}" "--config requires a file path"
        _load_env_file "$cfg"
        ((i+=2)); continue;;
      *) ((i++));;
    esac
  done

  # Second pass: parse all flags (CLI overrides template/env)
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help) _usage; exit 0 ;;
      -i|--interactive) INTERACTIVE_MODE="true"; shift ;;
      --with-monitoring) ENABLE_MONITORING="true"; shift ;;
      --no-monitoring)   ENABLE_MONITORING="false"; shift ;;
      --port)    APP_PORT="${2:?}"; shift 2 ;;
      --data-dir) DATA_DIR="${2:?}"; shift 2 ;;
      --app-cpu) APP_CPU_LIMIT="${2:?}"; shift 2 ;;
      --app-mem) APP_MEM_LIMIT="${2:?}"; shift 2 ;;
      --config)  shift 2 ;; # already handled in first pass
      --write-effective) OUTPUT_EFFECTIVE_CONFIG="${2:?}"; shift 2 ;;
      *) die "${E_INVALID_INPUT}" "Unknown option: $1" ;;
    esac
  done

  # If NON_INTERACTIVE=1 is set, force interactive off
  if (( NON_INTERACTIVE == 1 )); then
    INTERACTIVE_MODE="false"
  fi

  # Post-parse validation
  log_info "Configuration loaded. Final values:"
  log_info "  -> App Port: ${APP_PORT}"
  log_info "  -> Data Directory: ${DATA_DIR}"
  log_info "  -> Monitoring: ${ENABLE_MONITORING}"
  log_info "  -> App CPU limit: ${APP_CPU_LIMIT}, App MEM limit: ${APP_MEM_LIMIT}"

  _validate_values

  # Optionally write normalized config for later stages / reproducibility
  if [[ -n "${OUTPUT_EFFECTIVE_CONFIG}" ]]; then
    _write_effective_config "${OUTPUT_EFFECTIVE_CONFIG}"
  fi

  # Export for orchestrator
  export APP_PORT DATA_DIR ENABLE_MONITORING APP_CPU_LIMIT APP_MEM_LIMIT INTERACTIVE_MODE
}
