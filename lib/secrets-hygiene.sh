#!/usr/bin/env bash
set -Eeuo pipefail
shopt -s lastpipe 2>/dev/null || true

# Strict IFS for safer word splitting
IFS=$'\n\t'

# secrets-hygiene.sh - Secure credential handling and secrets management

# Prevent multiple sourcing
[[ -n "${SECRETS_HYGIENE_LIB_SOURCED:-}" ]] && return 0
readonly SECRETS_HYGIENE_LIB_SOURCED=1

# Source required libraries
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/error-handling.sh"

# =============================================================================
# SECURE FILE OPERATIONS
# =============================================================================

# Write content to file with secure permissions
# Usage: write_secure_file <file_path> <content> [mode] [no_echo]
write_secure_file() {
    local file_path="$1"
    local content="$2"
    local mode="${3:-600}"  # Default to owner read/write only
    local no_echo="${4:-false}"
    
    if [[ -z "$file_path" || -z "$content" ]]; then
        log_message ERROR "write_secure_file requires file_path and content"
        return 1
    fi
    
    # Ensure parent directory exists with secure permissions
    local parent_dir
    parent_dir="$(dirname "$file_path")"
    if [[ ! -d "$parent_dir" ]]; then
        if ! mkdir -p "$parent_dir"; then
            log_message ERROR "Failed to create directory: $parent_dir"
            return 1
        fi
        # Secure directory permissions (owner only)
        if ! chmod 700 "$parent_dir"; then
            log_message ERROR "Failed to secure directory permissions: $parent_dir"
            return 1
        fi
    fi
    
    # Create temporary file with secure permissions
    local temp_file
    temp_file="$(mktemp "${file_path}.XXXXXX")" || {
        log_message ERROR "Failed to create temporary file for: $file_path"
        return 1
    }
    
    # Set secure permissions immediately
    if ! chmod "$mode" "$temp_file"; then
        log_message ERROR "Failed to set permissions on temporary file: $temp_file"
        rm -f "$temp_file"
        return 1
    fi
    
    # Write content to temporary file
    if ! printf '%s' "$content" > "$temp_file"; then
        log_message ERROR "Failed to write content to: $temp_file"
        rm -f "$temp_file"
        return 1
    fi
    
    # Atomic move to final location
    if ! mv "$temp_file" "$file_path"; then
        log_message ERROR "Failed to move temporary file to: $file_path"
        rm -f "$temp_file"
        return 1
    fi
    
    # Verify final permissions
    if ! chmod "$mode" "$file_path"; then
        log_message ERROR "Failed to set final permissions on: $file_path"
        return 1
    fi
    
    if [[ "$no_echo" != "true" ]]; then
        log_message INFO "Securely written file: $file_path (mode: $mode)"
    fi
    
    return 0
}

# Write credentials to secure .env file
# Usage: write_secure_env <env_file> <key1=value1> [key2=value2] ...
write_secure_env() {
    local env_file="$1"
    shift
    
    if [[ -z "$env_file" || $# -eq 0 ]]; then
        log_message ERROR "write_secure_env requires env_file and at least one key=value pair"
        return 1
    fi
    
    local content
    content="# Generated by $(basename "$0") at $(date)\n"
    content+="# Secure credentials - DO NOT commit to version control\n\n"
    
    for kv_pair in "$@"; do
        if [[ "$kv_pair" =~ ^[A-Z_][A-Z0-9_]*=.* ]]; then
            content+="${kv_pair}\n"
        else
            log_message WARN "Skipping invalid environment variable format: $kv_pair"
        fi
    done
    
    write_secure_file "$env_file" "$(printf "$content")" 600 true
}

# =============================================================================
# CREDENTIAL MANAGEMENT
# =============================================================================

# Generate secure random password
# Usage: generate_secure_password [length] [character_set]
generate_secure_password() {
    local length="${1:-16}"
    local charset="${2:-A-Za-z0-9@#%^&*+=}"
    
    if ! command -v openssl >/dev/null 2>&1; then
        log_message ERROR "OpenSSL not available for secure password generation"
        return 1
    fi
    
    # Generate cryptographically secure password
    openssl rand -base64 32 | tr -d "=+/" | cut -c1-"$length"
}

# Securely prompt for password without echoing
# Usage: secure_password_prompt <prompt_message> <var_name>
secure_password_prompt() {
    local prompt_message="$1"
    local var_name="$2"
    
    if [[ -z "$prompt_message" || -z "$var_name" ]]; then
        log_message ERROR "secure_password_prompt requires prompt_message and var_name"
        return 1
    fi
    
    local password
    printf "%s: " "$prompt_message" >&2
    read -rs password
    printf "\n" >&2
    
    if [[ -z "$password" ]]; then
        log_message ERROR "Password cannot be empty"
        return 1
    fi
    
    # Set the variable in the calling scope
    printf -v "$var_name" '%s' "$password"
    
    # Clear local variable
    unset password
    
    return 0
}

# Validate password strength
# Usage: validate_password_strength <password> [min_length]
validate_password_strength() {
    local password="$1"
    local min_length="${2:-8}"
    
    if [[ -z "$password" ]]; then
        log_message ERROR "Password cannot be empty"
        return 1
    fi
    
    if [[ ${#password} -lt $min_length ]]; then
        log_message ERROR "Password must be at least $min_length characters long"
        return 1
    fi
    
    # Check for uppercase, lowercase, digit, and special character
    local has_upper has_lower has_digit has_special
    has_upper=0; has_lower=0; has_digit=0; has_special=0
    
    [[ "$password" =~ [A-Z] ]] && has_upper=1
    [[ "$password" =~ [a-z] ]] && has_lower=1
    [[ "$password" =~ [0-9] ]] && has_digit=1
    [[ "$password" =~ [^A-Za-z0-9] ]] && has_special=1
    
    local complexity_score=$((has_upper + has_lower + has_digit + has_special))
    
    if [[ $complexity_score -lt 3 ]]; then
        log_message ERROR "Password must contain at least 3 of: uppercase, lowercase, digit, special character"
        return 1
    fi
    
    return 0
}

# =============================================================================
# SECURE LOGGING
# =============================================================================

# Log message while masking sensitive information
# Usage: log_secure <level> <message> [mask_patterns...]
log_secure() {
    local level="$1"
    local message="$2"
    shift 2
    
    local masked_message="$message"
    
    # Default patterns to mask
    local default_patterns=(
        "password=[^[:space:]]*"
        "token=[^[:space:]]*"
        "secret=[^[:space:]]*"
        "key=[^[:space:]]*"
        "SPLUNK_PASSWORD=[^[:space:]]*"
        "CLUSTER_SECRET=[^[:space:]]*"
    )
    
    # Combine default patterns with user-provided ones
    local all_patterns=("${default_patterns[@]}" "$@")
    
    # Mask sensitive patterns
    for pattern in "${all_patterns[@]}"; do
        if [[ -n "$pattern" ]]; then
            masked_message=$(echo "$masked_message" | sed -E "s/${pattern}/[REDACTED]/gi")
        fi
    done
    
    log_message "$level" "$masked_message"
}

# =============================================================================
# ENVIRONMENT SANITIZATION
# =============================================================================

# Remove sensitive variables from environment
# Usage: sanitize_environment [var_patterns...]
sanitize_environment() {
    local patterns=(
        "*PASSWORD*"
        "*SECRET*"
        "*TOKEN*"
        "*KEY*"
        "*PASS*"
        "*CRED*"
    )
    
    # Add user-provided patterns
    patterns+=("$@")
    
    local sanitized_count=0
    
    for pattern in "${patterns[@]}"; do
        # Use compgen to find matching variables
        while IFS= read -r var_name; do
            if [[ -n "$var_name" ]]; then
                unset "$var_name"
                ((sanitized_count++))
            fi
        done < <(compgen -v | grep -E "$(echo "$pattern" | sed 's/\*/.*/')") 2>/dev/null || true
    done
    
    if [[ $sanitized_count -gt 0 ]]; then
        log_message INFO "Sanitized $sanitized_count sensitive environment variables"
    fi
}

# =============================================================================
# SECRET ROTATION
# =============================================================================

# Rotate secret in secure file
# Usage: rotate_secret <file_path> <secret_name> [generator_function]
rotate_secret() {
    local file_path="$1"
    local secret_name="$2"
    local generator_function="${3:-generate_secure_password}"
    
    if [[ -z "$file_path" || -z "$secret_name" ]]; then
        log_message ERROR "rotate_secret requires file_path and secret_name"
        return 1
    fi
    
    if [[ ! -f "$file_path" ]]; then
        log_message ERROR "Secret file not found: $file_path"
        return 1
    fi
    
    # Generate new secret
    local new_secret
    if ! new_secret=$($generator_function); then
        log_message ERROR "Failed to generate new secret for: $secret_name"
        return 1
    fi
    
    # Create backup with timestamp
    local backup_file="${file_path}.backup.$(date +%Y%m%d_%H%M%S)"
    if ! cp "$file_path" "$backup_file"; then
        log_message ERROR "Failed to create backup: $backup_file"
        return 1
    fi
    
    # Update secret in file
    if ! sed -i.tmp "s/^${secret_name}=.*/${secret_name}=${new_secret}/" "$file_path"; then
        log_message ERROR "Failed to update secret in: $file_path"
        # Restore from backup
        cp "$backup_file" "$file_path"
        return 1
    fi
    
    # Remove temporary file created by sed
    rm -f "${file_path}.tmp"
    
    # Secure permissions on backup
    chmod 600 "$backup_file"
    
    log_message INFO "Rotated secret '$secret_name' in $file_path (backup: $backup_file)"
    
    # Clear sensitive variable
    unset new_secret
    
    return 0
}

# =============================================================================
# VERIFICATION FUNCTIONS
# =============================================================================

# Verify file has secure permissions
# Usage: verify_secure_permissions <file_path> [expected_mode]
verify_secure_permissions() {
    local file_path="$1"
    local expected_mode="${2:-600}"
    
    if [[ ! -f "$file_path" ]]; then
        log_message ERROR "File not found: $file_path"
        return 1
    fi
    
    local actual_mode
    actual_mode=$(stat -c "%a" "$file_path" 2>/dev/null) || {
        log_message ERROR "Failed to get permissions for: $file_path"
        return 1
    }
    
    if [[ "$actual_mode" != "$expected_mode" ]]; then
        log_message ERROR "Insecure permissions on $file_path: $actual_mode (expected: $expected_mode)"
        return 1
    fi
    
    log_message DEBUG "Verified secure permissions on $file_path: $actual_mode"
    return 0
}

# Check for sensitive data in logs or output
# Usage: check_for_sensitive_leaks <text>
check_for_sensitive_leaks() {
    local text="$1"
    
    local sensitive_patterns=(
        "password"
        "secret"
        "token"
        "key"
        "credential"
    )
    
    local found_leaks=()
    
    for pattern in "${sensitive_patterns[@]}"; do
        if echo "$text" | grep -qi "$pattern"; then
            found_leaks+=("$pattern")
        fi
    done
    
    if [[ ${#found_leaks[@]} -gt 0 ]]; then
        log_message WARN "Potential sensitive data leaks detected: ${found_leaks[*]}"
        return 1
    fi
    
    return 0
}

# =============================================================================
# INITIALIZATION
# =============================================================================

# Initialize secrets directory with secure permissions
# Usage: init_secrets_directory <secrets_dir>
init_secrets_directory() {
    local secrets_dir="$1"
    
    if [[ -z "$secrets_dir" ]]; then
        log_message ERROR "init_secrets_directory requires secrets_dir path"
        return 1
    fi
    
    # Create directory with secure permissions
    if ! mkdir -p "$secrets_dir"; then
        log_message ERROR "Failed to create secrets directory: $secrets_dir"
        return 1
    fi
    
    # Set owner-only permissions
    if ! chmod 700 "$secrets_dir"; then
        log_message ERROR "Failed to set secure permissions on: $secrets_dir"
        return 1
    fi
    
    # Create .gitignore to prevent accidental commits
    local gitignore_file="$secrets_dir/.gitignore"
    if [[ ! -f "$gitignore_file" ]]; then
        write_secure_file "$gitignore_file" "# Ignore all files in secrets directory\n*\n!.gitignore\n" 644
    fi
    
    log_message INFO "Initialized secure secrets directory: $secrets_dir"
    return 0
}

# Export functions for use in other scripts
export -f write_secure_file write_secure_env generate_secure_password
export -f secure_password_prompt validate_password_strength log_secure
export -f sanitize_environment rotate_secret verify_secure_permissions
export -f check_for_sensitive_leaks init_secrets_directory
