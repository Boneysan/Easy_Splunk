#!/usr/bin/env bash
set -Eeuo pipefail
shopt -s lastpipe 2>/dev/null || true

# Strict IFS for safer word splitting
IFS=$'\n\t'

# Global trap for useful diagnostics
trap 'rc=$?; echo "[ERROR] ${BASH_SOURCE[0]}:$LINENO exited with $rc" >&2; exit $rc' ERR

# ==============================================================================
# lib/runtime.sh - Consolidated Runtime Detection and Lock Management
# ==============================================================================
# Purpose: Single source for runtime detection and .orchestrator.lock management
# Dependencies: lib/core.sh must be sourced first
# Version: 1.0.0
# ==============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# ---- Version and Guard ---------------------------------------------------------
if [[ -n "${RUNTIME_LIB_VERSION:-}" ]]; then
    # Already loaded
    return 0 2>/dev/null || true
fi
readonly RUNTIME_LIB_VERSION="1.0.0"

# ---- Global Variables ----------------------------------------------------------
CONTAINER_RUNTIME=""
COMPOSE_IMPL=""
COMPOSE_SUPPORTS_SECRETS=""
COMPOSE_SUPPORTS_HEALTHCHECK=""
COMPOSE_SUPPORTS_PROFILES=""
COMPOSE_SUPPORTS_BUILDKIT=""
DOCKER_NETWORK_AVAILABLE=""
CONTAINER_ROOTLESS=""
ORCHESTRATOR_LOCK_FILE=".orchestrator.lock"

# ---- Lock File Management -----------------------------------------------------

# read_orchestrator_lock
# Reads the current runtime lock file and sets global variables
read_orchestrator_lock() {
    local lock_file="${SCRIPT_DIR}/../${ORCHESTRATOR_LOCK_FILE}"

    if [[ ! -f "$lock_file" ]]; then
        log_debug "No orchestrator lock file found at: $lock_file"
        return 1
    fi

    # Read lock file safely
    local locked_runtime=""
    local locked_compose=""
    local timestamp=""
    local pid=""

    while IFS='=' read -r key value; do
        case "$key" in
            RUNTIME) locked_runtime="$value" ;;
            COMPOSE) locked_compose="$value" ;;
            TIMESTAMP) timestamp="$value" ;;
            PID) pid="$value" ;;
        esac
    done < "$lock_file"

    if [[ -z "$locked_runtime" ]]; then
        log_warn "Invalid or empty orchestrator lock file"
        return 1
    fi

    # Validate that the PID is still running (if provided)
    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
        log_debug "Lock file is held by running process (PID: $pid)"
    elif [[ -n "$pid" ]]; then
        log_warn "Lock file references dead process (PID: $pid), lock may be stale"
    fi

    # Set global variables
    CONTAINER_RUNTIME="$locked_runtime"
    COMPOSE_IMPL="$locked_compose"

    log_debug "Loaded runtime from lock file: ${CONTAINER_RUNTIME}"
    return 0
}

# write_orchestrator_lock
# Writes the current runtime configuration to lock file
write_orchestrator_lock() {
    local runtime="${1:-${CONTAINER_RUNTIME}}"
    local compose="${2:-${COMPOSE_IMPL}}"
    local lock_file="${SCRIPT_DIR}/../${ORCHESTRATOR_LOCK_FILE}"

    if [[ -z "$runtime" ]]; then
        log_error "Cannot write lock file: no runtime specified"
        return 1
    fi

    # Create lock file atomically
    local temp_file="${lock_file}.tmp"
    {
        echo "# Container Runtime Lockfile"
        echo "# Generated by detect_runtime() on $(date)"
        echo "# This file ensures deterministic runtime selection across sessions"
        echo ""
        echo "RUNTIME=${runtime}"
        echo "COMPOSE=${compose}"
        echo "TIMESTAMP=$(date +%s)"
        echo "PID=$$"
    } > "$temp_file"

    # Atomic move
    mv "$temp_file" "$lock_file"
    log_debug "Wrote orchestrator lock file: $lock_file"
    return 0
}

# clear_orchestrator_lock
# Removes the orchestrator lock file
clear_orchestrator_lock() {
    local lock_file="${SCRIPT_DIR}/../${ORCHESTRATOR_LOCK_FILE}"

    if [[ -f "$lock_file" ]]; then
        rm -f "$lock_file"
        log_debug "Cleared orchestrator lock file: $lock_file"
    fi
}

# ---- Runtime Detection ---------------------------------------------------------

# detect_container_runtime
# Detects the best available container runtime (docker or podman)
detect_container_runtime() {
    # Check if we have a cached/locked runtime
    if read_orchestrator_lock 2>/dev/null; then
        echo "$CONTAINER_RUNTIME"
        return 0
    fi

    # Detect available runtime
    local detected_runtime=""

    if command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
        detected_runtime="docker"
    elif command -v podman >/dev/null 2>&1 && podman info >/dev/null 2>&1; then
        detected_runtime="podman"
    else
        log_error "No working container runtime detected (docker or podman)"
        return 1
    fi

    # Set global variable
    CONTAINER_RUNTIME="$detected_runtime"

    log_debug "Detected container runtime: $CONTAINER_RUNTIME"
    echo "$CONTAINER_RUNTIME"
    return 0
}

# detect_compose_implementation
# Detects the best compose implementation for the current runtime
detect_compose_implementation() {
    local runtime="${1:-$(detect_container_runtime)}"

    case "$runtime" in
        docker)
            if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
                COMPOSE_IMPL="docker compose"
            elif command -v docker-compose >/dev/null 2>&1; then
                COMPOSE_IMPL="docker-compose"
            else
                log_error "No Docker Compose implementation found"
                return 1
            fi
            ;;
        podman)
            if command -v podman >/dev/null 2>&1 && podman compose version >/dev/null 2>&1; then
                COMPOSE_IMPL="podman compose"
            else
                log_error "Podman Compose not found"
                return 1
            fi
            ;;
        *)
            log_error "Unsupported container runtime: $runtime"
            return 1
            ;;
    esac

    log_debug "Detected compose implementation: $COMPOSE_IMPL"
    echo "$COMPOSE_IMPL"
    return 0
}

# ---- Runtime Summary -----------------------------------------------------------

# enhanced_runtime_summary
# Displays comprehensive runtime information
enhanced_runtime_summary() {
    if [[ -n "${CONTAINER_RUNTIME:-}" ]]; then
        log_info "=== Container Runtime Summary ==="
        log_info "Runtime: ${CONTAINER_RUNTIME}"
        log_info "Compose: ${COMPOSE_IMPL:-unknown}"
        log_info "Capabilities:"
        log_info "  Secrets: ${COMPOSE_SUPPORTS_SECRETS:-unknown}"
        log_info "  Healthchecks: ${COMPOSE_SUPPORTS_HEALTHCHECK:-unknown}"
        log_info "  Profiles: ${COMPOSE_SUPPORTS_PROFILES:-unknown}"
        log_info "  BuildKit: ${COMPOSE_SUPPORTS_BUILDKIT:-unknown}"
        log_info "Environment:"
        log_info "  Network Available: ${DOCKER_NETWORK_AVAILABLE:-unknown}"
        log_info "  Rootless: ${CONTAINER_ROOTLESS:-unknown}"
        log_info "  Air-gapped: ${AIR_GAPPED_MODE:-false}"
    else
        log_info "Container runtime summary not available - runtime not detected"
    fi
}

# ---- Initialization -----------------------------------------------------------

# initialize_runtime
# Main entry point for runtime detection and lock management
initialize_runtime() {
    local force_redetect="${1:-false}"

    if [[ "$force_redetect" == "true" ]] || ! read_orchestrator_lock 2>/dev/null; then
        log_info "Detecting container runtime..."

        if ! detect_container_runtime; then
            log_error "Failed to detect container runtime"
            return 1
        fi

        if ! detect_compose_implementation "$CONTAINER_RUNTIME"; then
            log_error "Failed to detect compose implementation"
            return 1
        fi

        # Write lock file
        write_orchestrator_lock "$CONTAINER_RUNTIME" "$COMPOSE_IMPL"
    else
        log_info "Using cached runtime configuration"
    fi

    enhanced_runtime_summary
    return 0
}

# ---- Export Functions ----------------------------------------------------------
export -f detect_container_runtime
export -f detect_compose_implementation
export -f read_orchestrator_lock
export -f write_orchestrator_lock
export -f clear_orchestrator_lock
export -f enhanced_runtime_summary
export -f initialize_runtime

log_debug "Runtime library loaded (version: $RUNTIME_LIB_VERSION)"
